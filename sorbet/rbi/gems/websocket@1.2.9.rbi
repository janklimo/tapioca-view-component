# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `websocket` gem.
# Please instead update this file by running `bin/tapioca gem websocket`.

module WebSocket
  class << self
    def max_frame_size; end
    def max_frame_size=(val); end
    def should_raise; end
    def should_raise=(val); end
  end
end

WebSocket::DEFAULT_VERSION = T.let(T.unsafe(nil), Integer)
class WebSocket::Error < ::RuntimeError; end
class WebSocket::Error::Frame < ::WebSocket::Error; end

class WebSocket::Error::Frame::ControlFramePayloadTooLong < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::DataFrameInsteadContinuation < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::FragmentedControlFrame < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::Invalid < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::InvalidPayloadEncoding < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::MaskTooShort < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::ReservedBitUsed < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::TooLong < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnexpectedContinuationFrame < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnknownCloseCode < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnknownFrameType < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnknownOpcode < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Frame::UnknownVersion < ::WebSocket::Error::Frame
  def message; end
end

class WebSocket::Error::Handshake < ::WebSocket::Error; end

class WebSocket::Error::Handshake::GetRequestRequired < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::InvalidAuthentication < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::InvalidHeader < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::InvalidStatusCode < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::NoHostProvided < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::UnknownVersion < ::WebSocket::Error::Handshake
  def message; end
end

class WebSocket::Error::Handshake::UnsupportedProtocol < ::WebSocket::Error::Handshake
  def message; end
end

module WebSocket::ExceptionHandler
  mixes_in_class_methods ::WebSocket::ExceptionHandler::ClassMethods

  def error; end
  def error=(_arg0); end

  class << self
    def included(base); end
  end
end

module WebSocket::ExceptionHandler::ClassMethods
  def rescue_method(method_name, options = T.unsafe(nil)); end
end

module WebSocket::Frame; end

class WebSocket::Frame::Base
  include ::WebSocket::ExceptionHandler
  include ::WebSocket::NiceInspect
  extend ::WebSocket::ExceptionHandler::ClassMethods

  def initialize(*args); end

  def code; end
  def code=(_arg0); end
  def data; end
  def data=(_arg0); end
  def error; end
  def error?; end
  def initialize_with_rescue(*args); end
  def support_type?; end
  def supported_frames; end
  def type; end
  def version; end

  private

  def include_version; end
  def initialize_without_rescue(args = T.unsafe(nil)); end
end

class WebSocket::Frame::Data < ::String
  def initialize(*args); end

  def <<(*args); end
  def convert_args(args); end
  def getbytes(start_index, count); end
  def mask(payload, mask); end
  def set_mask; end
  def unset_mask; end
end

module WebSocket::Frame::Handler; end

class WebSocket::Frame::Handler::Base
  def initialize(frame); end

  def decode_frame; end
  def encode_frame; end

  private

  def control_frame?(frame_type); end
  def data_frame?(frame_type); end
end

class WebSocket::Frame::Handler::Handler03 < ::WebSocket::Frame::Handler::Base
  def initialize(frame); end

  def decode_frame; end
  def encode_frame; end
  def masking?; end
  def supported_frames; end

  private

  def buffer_exists?(buffer_number); end
  def decode_continuation_frame(application_data, frame_type); end
  def decode_finish_continuation_frame(application_data); end
  def decode_first_byte; end
  def decode_header; end
  def decode_payload(payload_length, mask); end
  def decode_payload_length(length); end
  def decode_second_byte(frame_type); end
  def encode_header; end
  def encode_payload_length(length, mask); end
  def fin; end
  def opcode_to_type(opcode); end
  def type_to_opcode(frame_type); end
end

WebSocket::Frame::Handler::Handler03::FRAME_TYPES = T.let(T.unsafe(nil), Hash)
WebSocket::Frame::Handler::Handler03::FRAME_TYPES_INVERSE = T.let(T.unsafe(nil), Hash)

class WebSocket::Frame::Handler::Handler04 < ::WebSocket::Frame::Handler::Handler03
  private

  def fin; end
end

class WebSocket::Frame::Handler::Handler05 < ::WebSocket::Frame::Handler::Handler04
  def masking?; end
end

class WebSocket::Frame::Handler::Handler07 < ::WebSocket::Frame::Handler::Handler05
  def decode_frame; end
  def encode_frame; end

  private

  def close_code?(frame); end
  def opcode_to_type(opcode); end
  def type_to_opcode(frame_type); end
  def valid_code?(code); end
  def valid_encoding?(data); end
end

WebSocket::Frame::Handler::Handler07::FRAME_TYPES = T.let(T.unsafe(nil), Hash)
WebSocket::Frame::Handler::Handler07::FRAME_TYPES_INVERSE = T.let(T.unsafe(nil), Hash)

class WebSocket::Frame::Handler::Handler75 < ::WebSocket::Frame::Handler::Base
  def decode_frame; end
  def encode_frame; end
  def supported_frames; end
end

class WebSocket::Frame::Incoming < ::WebSocket::Frame::Base
  def initialize(args = T.unsafe(nil)); end

  def <<(data); end
  def decoded?; end
  def next(*args); end
  def next_with_rescue(*args); end
  def next_without_rescue; end
  def to_s; end
end

class WebSocket::Frame::Incoming::Client < ::WebSocket::Frame::Incoming
  def incoming_masking?; end
  def outgoing_masking?; end
end

class WebSocket::Frame::Incoming::Server < ::WebSocket::Frame::Incoming
  def incoming_masking?; end
  def outgoing_masking?; end
end

class WebSocket::Frame::Outgoing < ::WebSocket::Frame::Base
  def require_sending?; end
  def supported?; end
  def to_s(*args); end
  def to_s_with_rescue(*args); end
  def to_s_without_rescue; end
end

class WebSocket::Frame::Outgoing::Client < ::WebSocket::Frame::Outgoing
  def incoming_masking?; end
  def outgoing_masking?; end
end

class WebSocket::Frame::Outgoing::Server < ::WebSocket::Frame::Outgoing
  def incoming_masking?; end
  def outgoing_masking?; end
end

module WebSocket::Handshake; end

class WebSocket::Handshake::Base
  include ::WebSocket::ExceptionHandler
  include ::WebSocket::NiceInspect
  extend ::WebSocket::ExceptionHandler::ClassMethods

  def initialize(args = T.unsafe(nil)); end

  def <<(data); end
  def finished?; end
  def headers; end
  def host; end
  def leftovers; end
  def path; end
  def port; end
  def protocols; end
  def query; end
  def secure; end
  def should_respond?; end
  def state; end
  def to_s(*args); end
  def to_s_with_rescue(*args); end
  def to_s_without_rescue; end
  def uri; end
  def valid?(*args); end
  def version; end

  private

  def error=(message); end
  def parse_data; end
  def reserved_leftover_lines; end
end

WebSocket::Handshake::Base::HEADER = T.let(T.unsafe(nil), Regexp)

class WebSocket::Handshake::Client < ::WebSocket::Handshake::Base
  def initialize(*args); end

  def <<(*args); end
  def headers; end
  def initialize_with_rescue(*args); end
  def origin; end
  def should_respond?; end

  private

  def include_version; end
  def initialize_without_rescue(args = T.unsafe(nil)); end
  def parse_first_line(line); end
end

WebSocket::Handshake::Client::FIRST_LINE = T.let(T.unsafe(nil), Regexp)
module WebSocket::Handshake::Handler; end

class WebSocket::Handshake::Handler::Base
  def initialize(handshake); end

  def to_s; end
  def valid?; end

  private

  def finishing_line; end
  def handshake_keys; end
  def header_line; end
end

class WebSocket::Handshake::Handler::Client < ::WebSocket::Handshake::Handler::Base
  private

  def handshake_keys; end
  def header_line; end
  def verify_protocol; end
end

class WebSocket::Handshake::Handler::Client01 < ::WebSocket::Handshake::Handler::Client76
  private

  def handshake_keys; end
end

class WebSocket::Handshake::Handler::Client04 < ::WebSocket::Handshake::Handler::Client
  def valid?; end

  private

  def accept; end
  def handshake_keys; end
  def key; end
  def provided_protocols; end
  def supported_protocols; end
  def verify_accept; end
end

class WebSocket::Handshake::Handler::Client11 < ::WebSocket::Handshake::Handler::Client04
  private

  def handshake_keys; end
end

class WebSocket::Handshake::Handler::Client75 < ::WebSocket::Handshake::Handler::Client
  def valid?; end

  private

  def handshake_keys; end
  def provided_protocols; end
  def supported_protocols; end
end

class WebSocket::Handshake::Handler::Client76 < ::WebSocket::Handshake::Handler::Client75
  def valid?; end

  private

  def challenge; end
  def finishing_line; end
  def generate_key(key); end
  def generate_key3; end
  def handshake_keys; end
  def key1; end
  def key2; end
  def key3; end
  def provided_protocols; end
  def reserved_leftover_lines; end
  def verify_challenge; end
end

WebSocket::Handshake::Handler::Client76::NOISE_CHARS = T.let(T.unsafe(nil), Array)
class WebSocket::Handshake::Handler::Server < ::WebSocket::Handshake::Handler::Base; end

class WebSocket::Handshake::Handler::Server04 < ::WebSocket::Handshake::Handler::Server
  def valid?; end

  private

  def handshake_keys; end
  def header_line; end
  def key; end
  def protocol; end
  def signature; end
  def verify_key; end
end

class WebSocket::Handshake::Handler::Server75 < ::WebSocket::Handshake::Handler::Server
  private

  def handshake_keys; end
  def header_line; end
  def headers; end
  def protocol; end
end

class WebSocket::Handshake::Handler::Server76 < ::WebSocket::Handshake::Handler::Server75
  def valid?; end

  private

  def challenge_response; end
  def finishing_line; end
  def header_line; end
  def headers; end
  def numbers_over_spaces(string); end
  def reserved_leftover_lines; end
end

class WebSocket::Handshake::Server < ::WebSocket::Handshake::Base
  def initialize(args = T.unsafe(nil)); end

  def <<(*args); end
  def from_hash(hash); end
  def from_rack(env); end
  def host; end
  def port; end
  def should_respond?; end

  private

  def include_version; end
  def parse_first_line(line); end
  def set_version; end
end

WebSocket::Handshake::Server::PATH = T.let(T.unsafe(nil), Regexp)

module WebSocket::Mask
  class << self
    def mask(_arg0, _arg1); end
  end
end

module WebSocket::NiceInspect
  def inspect; end
end

WebSocket::ROOT = T.let(T.unsafe(nil), String)
